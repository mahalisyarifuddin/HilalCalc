<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MABBIMS Hijri Calendar</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
			--formula-bg: #f8f9fa;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
				--formula-bg: #1e222b;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
			--formula-bg: #1e222b;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			font-family: sans-serif;
			background-color: var(--background);
			color: var(--text);
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 960px;
			width: 100%;
			padding: 2rem;
			position: relative;
			margin: 2rem 0;
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		label { 
			display: block; 
			font-weight: 700; 
			margin-bottom: 0.25rem; 
			font-size: 0.9rem; 
		}
		input, select, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		button { 
			cursor: pointer; 
			font-weight: 500; 
			transition: background 0.2s; 
		}
		button:hover { 
			opacity: 0.9; 
		}
		button:disabled { 
			opacity: 0.6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary { 
			background: transparent; 
			border: 1px solid var(--border); 
			color: var(--text); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
		}
		.calendar-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1.5rem;
			flex-wrap: wrap;
			gap: 10px;
		}
		.calendar-grid {
			display: grid;
			grid-template-columns: repeat(7, minmax(50px, 1fr));
			gap: 1px;
			background: var(--border);
			border: 1px solid var(--border);
			border-radius: 4px;
			overflow-x: auto;
			min-width: 100%;
		}
		.day-header {
			background: var(--muted);
			padding: 10px;
			text-align: center;
			font-weight: bold;
			font-size: 0.9rem;
		}
		.day-cell {
			background: var(--surface);
			min-height: 100px;
			padding: 8px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			position: relative;
			overflow: hidden;
		}
		.day-cell.other-month { 
			opacity: 0.5; 
			background: var(--formula-bg); 
		}
		.day-cell.today { 
			background: var(--highlight-bg); 
		}
		.day-cell.selected { 
			border: 2px solid var(--primary); 
		}
		.day-cell:hover { 
			background: var(--muted); 
			cursor: pointer; 
		}
		.day-cell:focus { 
			outline: 2px solid var(--primary); 
			z-index: 10; 
		}
		.gregorian-date { 
			font-size: 1.2rem; 
			font-weight: 700; 
			order: 1; 
		}
		.hijri-wrapper { 
			order: 2; 
			text-align: right; 
		}
		.hijri-date { 
			font-size: 0.9rem; 
			color: var(--primary); 
			font-weight: 600; 
		}
		.hijri-month-name { 
			font-size: 0.75rem; 
			opacity: 0.8; 
		}
		.calendar-grid.hijri-primary .gregorian-date {
			order: 2;
			font-size: 0.9rem;
			font-weight: 600;
			text-align: right;
			color: var(--primary);
			align-self: flex-end;
			width: 100%;
		}
		.calendar-grid.hijri-primary .hijri-wrapper { 
			order: 1; 
			text-align: left; 
		}
		.calendar-grid.hijri-primary .hijri-date { 
			font-size: 1.2rem; 
			font-weight: 700; 
			color: var(--text); 
			text-align: left; 
		}
		.calendar-grid.hijri-primary .hijri-month-name { 
			text-align: left; 
		}
		.controls { 
			display: flex; 
			justify-content: center;
			margin-bottom: 1.5rem;
		}
		.control-group {
			width: 100%;
			max-width: 700px;
			background: var(--formula-bg);
			padding: 1.5rem;
			border-radius: 8px;
			border: 1px solid var(--border);
		}
		.row { 
			display: flex; 
			gap: 0.5rem; 
			margin-bottom: 0.5rem; 
		}
		.row > * { 
			flex: 1; 
		}
		dialog {
			background: var(--surface);
			color: var(--text);
			border: 1px solid var(--border);
			border-radius: 8px;
			padding: 1.5rem;
			max-width: 400px;
			width: 100%;
			margin: auto;
			position: fixed;
		}
		dialog::backdrop { 
			background: rgba(0, 0, 0, 0.5); 
		}
		.dialog-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1.5rem;
		}
		.dialog-header h3 { 
			font-size: 1.25rem; 
			font-weight: 600; 
			margin: 0; 
		}
		.close-button {
			background: transparent;
			color: var(--text);
			padding: .25rem;
			font-size: 1.5rem;
			line-height: 1;
			border: none;
			width: auto;
		}
		.close-button:hover { 
			background: var(--background); 
			color: var(--text); 
		}
		.group {
			background: var(--background);
			border: 1px solid var(--border);
			padding: 1rem;
			border-radius: 6px;
			margin-bottom: 1rem;
			position: relative;
		}
		dialog input:not([type=color]):not([type=range]), dialog textarea, dialog select, dialog button {
			width: 100%;
			padding: .5rem .75rem;
			border: 1px solid var(--border);
			border-radius: 4px;
			background: var(--surface);
			color: var(--text);
			margin-top: 4px;
			font-family: inherit;
			font-size: .95rem;
		}
		dialog button { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
			cursor: pointer; 
		}
		dialog button:hover { 
			background: var(--hover); 
		}
		.info-text { 
			font-size: 0.85rem; 
			opacity: 0.7; 
			margin-top: 1rem; 
			text-align: center; 
		}
		@media(max-width: 600px) {
			.selectors { 
				position: static; 
				justify-content: 
				flex-end; 
				margin-bottom: 1rem; 
			}
			.calendar-header { 
				flex-direction: row;
				align-items: center;
				flex-wrap: nowrap;
				gap: 5px;
			}
			.calendar-header h2 {
				font-size: 1.1rem;
				flex: 1;
				text-align: center;
				margin: 0;
				white-space: nowrap;
			}
			.day-cell { 
				min-height: 60px; 
				padding: 4px; 
			}
			.gregorian-date { 
				font-size: 1rem; 
			}
			.hijri-date { 
				font-size: 0.8rem; 
			}
			.calendar-grid.hijri-primary .hijri-date { 
				font-size: 1rem; 
			}
			.calendar-grid.hijri-primary .gregorian-date { 
				font-size: 0.8rem; 
			}
		}
		.spinner {
			display: inline-block;
			width: 1em;
			height: 1em;
			border: 2px solid currentColor;
			border-right-color: transparent;
			border-radius: 50%;
			animation: spin 0.75s linear infinite;
			vertical-align: text-bottom;
			margin-right: 4px;
		}
		@keyframes spin { 
			100% { 
				transform: rotate(360deg); 
			} 
		}
		.nav-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1rem;
		}
		.small-btn {
			width: auto;
			padding: 6px 12px;
			font-size: 0.9rem;
		}
		.input-group {
			display: flex;
			gap: 0.5rem;
			margin-bottom: 1rem;
			align-items: center;
		}
		.input-group > * {
			flex: 1;
		}
		.sr-only {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0,0,0,0);
			border: 0;
		}
		#hDayInput {
			flex: 0.6;
		}
		#hMonthInput {
			flex: 2;
		}
		#hYearInput {
			flex: 1;
		}
		#goHBtn {
			flex: 0.4;
			min-width: 40px;
			padding: 0.5rem;
			font-weight: bold;
		}
		details {
			margin-top: 2rem;
			border-top: 1px solid var(--border);
			padding-top: 1rem;
		}
		summary {
			cursor: pointer;
			opacity: 0.8;
			font-size: 0.9rem;
			margin-bottom: 0.5rem;
		}
		summary:hover {
			opacity: 1;
			color: var(--primary);
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<button id="prefBtn" class="secondary" style="width:auto; padding: 6px 12px;" data-i18n="prefTitle"></button>
		</div>
		<h1 id="appTitle" data-i18n="appTitle"></h1>
		<p id="appSubtitle" style="opacity: 0.7; margin-bottom: 2rem;"></p>
		<div class="controls">
			<div class="control-group">
				<label class="sr-only" data-i18n="gDateLabel"></label>
				<div class="input-group">
					<input type="date" id="gDateInput" data-i18n-aria="gDateLabel">
					<button id="todayBtn" class="secondary" data-i18n="today" style="flex:0.3"></button>
				</div>
				<div class="input-group" style="margin-bottom:0">
					<input type="number" id="hDayInput" placeholder="D" min="1" max="30" data-i18n-aria="hDayLabel">
					<select id="hMonthInput" data-i18n-aria="hMonthLabel"></select>
					<input type="number" id="hYearInput" placeholder="Year" min="1300" max="2500" data-i18n-aria="hYearLabel" data-i18n-placeholder="yearPlaceholder">
					<button id="goHBtn" class="primary" aria-label="Go to Hijri Date" data-i18n-aria="goHBtnLabel">&rarr;</button>
				</div>
			</div>
		</div>
		<div class="calendar-header">
			<button id="prevMonthBtn" class="secondary" style="width: auto;" data-i18n="prevBtn" data-i18n-aria="prevMonthLabel"></button>
			<h2 id="monthDisplay"></h2>
			<button id="nextMonthBtn" class="secondary" style="width: auto;" data-i18n="nextBtn" data-i18n-aria="nextMonthLabel"></button>
		</div>
		<div class="calendar-grid" id="calendar"></div>
		<details>
			<summary><span data-i18n="formulaTitle"></span></summary>
			<p id="formulaDisplay" style="font-family: monospace; font-size: 0.9rem; background: var(--surface); padding: 5px; border: 1px solid var(--border); border-radius: 4px; margin-bottom: 5px;"></p>
			<p id="formulaDesc" style="font-size: 0.8rem; opacity: 0.8;" data-i18n="formulaDesc"></p>
			<p id="formulaNote" style="font-size: 0.8rem; opacity: 0.8; margin-top:5px;"></p>
			<p class="info-text" id="footerNote" data-i18n="footer"></p>
		</details>
	</div>
	<dialog id="prefDialog">
		<div class="dialog-header">
			<h3 id="prefTitle" data-i18n="prefTitle"></h3>
			<button id="closePref" class="close-button" aria-label="Close Settings">&times;</button>
		</div>
		<div class="group">
			<label>
				<span id="langLabel" data-i18n="langLabel"></span>
				<select id="language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
			</label>
			<label>
				<span id="themeLabel" data-i18n="themeLabel"></span>
				<select id="theme"><option value="auto">Auto</option><option value="light">Light</option><option value="dark">Dark</option></select>
			</label>
			<label>
				<span id="primaryCalLabel" data-i18n="primaryCalLabel"></span>
				<select id="primaryCalendar"><option value="gregorian">Gregorian</option><option value="hijri">Hijri</option></select>
			</label>
			<label>
				<span id="calcModeLabel" data-i18n="calcModeLabel">Calculation Method</span>
				<select id="calcMode">
					<option value="astronomic">Astronomical (MABBIMS)</option>
					<option value="heuristic">Heuristic (Tabular)</option>
				</select>
			</label>
			<label>
				<span id="weekStartLabel" data-i18n="weekStartLabel"></span>
				<select id="weekStart"><option value="0">Sunday</option><option value="1">Monday</option><option value="6">Saturday</option></select>
			</label>
		</div>
		<div class="group">
			<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:.5rem">
				<label id="locLabel" style="margin-bottom:0" data-i18n="locLabel"></label>
				<button id="myLocBtn" style="width:auto; padding: .25rem .5rem; font-size:.8rem; background:transparent; color:var(--primary); border:none;" data-i18n="myLoc"></button>
			</div>
			<div class="row">
				<div style="flex:1"><label style="font-weight:normal; font-size:0.8em" data-i18n="latLabel"></label><input type="number" id="latInput" step="0.0001"></div>
				<div style="flex:1"><label style="font-weight:normal; font-size:0.8em" data-i18n="lonLabel"></label><input type="number" id="lonInput" step="0.0001"></div>
			</div>
		</div>
		<div class="group">
			<label id="adjLabel" data-i18n="adjLabel"></label>
			<input type="number" id="hijriAdj" value="0" min="-2" max="2">
			<small style="opacity: 0.6;" data-i18n="adjNote"></small>
		</div>
		<div style="display: flex; gap: 10px; margin-top: 1rem;">
			<button id="resetPrefBtn" class="secondary" data-i18n="reset"></button>
			<button id="savePrefBtn" class="primary" data-i18n="save"></button>
		</div>
	</dialog>
	<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
	<script>
		const text = {
			en: {
				appTitle: 'MABBIMS Hijri Calendar',
				gotoTitle: 'Go to Date',
				today: 'Today',
				formulaTitle: 'Linear Approximation',
				formulaDesc: 'Based on Composite Criteria (Mecca Alt≥3, Elong≥6.4; Viwa Alt≥0). Accuracy: 69.01% (1-10000 AH). Optimized for Obligatory Months.',
				prefTitle: 'Preferences',
				langLabel: 'Language',
				themeLabel: 'Theme',
				primaryCalLabel: 'Primary Calendar',
				weekStartLabel: 'Week starts on',
				locLabel: 'Location',
				adjLabel: 'Hijri Adjustment (Days)',
				save: 'Save & Close',
				reset: 'Reset Defaults',
				myLoc: 'Use My Location',
				locating: 'Locating...',
				go: 'Go',
				goH: 'Go to Hijri',
				months: ["Muharram", "Safar", "Rabi' al-awwal", "Rabi' al-thani", "Jumada al-awwal", "Jumada al-thani", "Rajab", "Sha'ban", "Ramadan", "Shawwal", "Dhu al-Qi'dah", "Dhu al-Hijjah"],
				days: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				footer: '* Dates start at sunset. MABBIMS Criteria: Alt ≥ 3°, Elong ≥ 6.4°.',
				gDateLabel: 'Gregorian Date',
				hDayLabel: 'Hijri Day',
				hMonthLabel: 'Hijri Month',
				hYearLabel: 'Hijri Year',
				goBtnLabel: 'Go to Gregorian Date',
				goHBtnLabel: 'Go to Hijri Date',
				prevMonthLabel: 'Previous Month',
				nextMonthLabel: 'Next Month',
				prevBtn: '← Prev',
				nextBtn: 'Next →',
				yearPlaceholder: 'Year',
				offlineWarning: 'Offline Mode: Using Linear Approximation',
				geoNotSupported: 'Geolocation is not supported by this browser.',
				errorLocation: 'Error getting location: ',
				offlineSuffix: ' (Offline/Linear)',
				latLabel: 'Lat',
				lonLabel: 'Lon',
				adjNote: 'Shifts the Linear formula.',
				themeAuto: 'Auto',
				themeLight: 'Light',
				themeDark: 'Dark',
				calGregorian: 'Gregorian',
				calHijri: 'Hijri',
				weekSun: 'Sunday',
				weekMon: 'Monday',
				weekSat: 'Saturday',
				dirN: 'N',
				dirS: 'S',
				dirE: 'E',
				dirW: 'W',
				calcModeLabel: 'Calculation Method',
				calcModeAstronomic: 'Astronomical (MABBIMS)',
				calcModeHeuristic: 'Linear Approximation',
				heuristicSuffix: ' (Linear)'
			},
			id: {
				appTitle: 'Kalender Hijriyah MABBIMS',
				gotoTitle: 'Ke Tanggal',
				today: 'Hari Ini',
				formulaTitle: 'Aproksimasi Linear',
				formulaDesc: 'Berdasarkan Kriteria Komposit (Makkah Alt≥3, Elong≥6.4; Viwa Alt≥0). Akurasi: 69.01% (1-10000 H). Dioptimalkan untuk Bulan Wajib.',
				prefTitle: 'Pengaturan',
				langLabel: 'Bahasa',
				themeLabel: 'Tema',
				primaryCalLabel: 'Kalender Utama',
				weekStartLabel: 'Awal pekan',
				locLabel: 'Lokasi',
				adjLabel: 'Penyesuaian Hijriyah (Hari)',
				save: 'Simpan & Tutup',
				reset: 'Atur Ulang',
				myLoc: 'Gunakan Lokasi Saya',
				locating: 'Mencari lokasi...',
				go: 'Buka',
				goH: 'Buka Hijriyah',
				months: ["Muharram", "Safar", "Rabiul Awal", "Rabiul Akhir", "Jumadil Awal", "Jumadil Akhir", "Rajab", "Syaban", "Ramadhan", "Syawal", "Dzulkaidah", "Dzulhijjah"],
				days: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
				footer: '* Tanggal dimulai saat maghrib. Kriteria MABBIMS: Alt ≥ 3°, Elong ≥ 6.4°.',
				gDateLabel: 'Tanggal Masehi',
				hDayLabel: 'Hari Hijriyah',
				hMonthLabel: 'Bulan Hijriyah',
				hYearLabel: 'Tahun Hijriyah',
				goBtnLabel: 'Buka Tanggal Masehi',
				goHBtnLabel: 'Buka Tanggal Hijriyah',
				prevMonthLabel: 'Bulan Sebelumnya',
				nextMonthLabel: 'Bulan Berikutnya',
				prevBtn: '← Sblm',
				nextBtn: 'Lanjut →',
				yearPlaceholder: 'Tahun',
				offlineWarning: 'Mode Offline: Menggunakan Aproksimasi Linear',
				geoNotSupported: 'Geolokasi tidak didukung oleh browser ini.',
				errorLocation: 'Gagal mendapatkan lokasi: ',
				offlineSuffix: ' (Offline/Linear)',
				latLabel: 'Lintang',
				lonLabel: 'Bujur',
				adjNote: 'Menggeser rumus Linear.',
				themeAuto: 'Otomatis',
				themeLight: 'Terang',
				themeDark: 'Gelap',
				calGregorian: 'Masehi',
				calHijri: 'Hijriyah',
				weekSun: 'Minggu',
				weekMon: 'Senin',
				weekSat: 'Sabtu',
				dirN: 'LU',
				dirS: 'LS',
				dirE: 'BT',
				dirW: 'BB',
				calcModeLabel: 'Metode Perhitungan',
				calcModeAstronomic: 'Astronomis (MABBIMS)',
				calcModeHeuristic: 'Aproksimasi Linear',
				heuristicSuffix: ' (Linear)'
			}
		};

		const elements = new Proxy({},{get:(_,id)=>document.getElementById(id) });

		let state = {
			lat: 6.075,
			lon: 95.1125,
			lang: navigator.language?.startsWith('id') ? 'id' : 'en',
			theme: 'auto',
			weekStart: 0,
			hijriAdj: 0,
			primaryCalendar: 'gregorian',
			calcMode: 'astronomic'
		};

		class HijriCalc {
			constructor() {
				(this.isOffline = (typeof Astronomy === 'undefined'),
				this.cacheVersion = 3,
				this.loadState(),
				state.viewDate = new Date(),
				this.setup(),
				this.updateLanguage(state.lang),
				this.applyTheme(state.theme),
				this.render(),
				this.isOffline && (()=>{
					console.warn("Astronomy Engine not loaded. Using Tabular method.");
					const warning = document.createElement('div');
					(warning.style.cssText = 'color:var(--danger);text-align:center;font-weight:400;margin-bottom:1rem',
					warning.setAttribute('data-i18n', 'offlineWarning'),
					warning.textContent = text[state.lang].offlineWarning,
					document.querySelector('.container')?.insertBefore(warning, document.querySelector('.container').firstChild));
				})());
			}

			loadState() {
				try {
					const saved = localStorage.getItem('hijriCalcState');
					saved && (()=>{
						const parsed = JSON.parse(saved);
						parsed.lat !== undefined && (state.lat = parsed.lat),
						parsed.lon !== undefined && (state.lon = parsed.lon),
						parsed.lang && (state.lang = parsed.lang),
						parsed.theme && (state.theme = parsed.theme),
						parsed.weekStart !== undefined && (state.weekStart = parsed.weekStart),
						parsed.hijriAdj !== undefined && (state.hijriAdj = parsed.hijriAdj),
						parsed.primaryCalendar && (state.primaryCalendar = parsed.primaryCalendar),
						parsed.calcMode && (state.calcMode = parsed.calcMode);
					})();
				} catch (e) { console.error("Failed to load state", e); }
			}

			loadCache() {
				try {
					const saved = localStorage.getItem('hijriCalcCache');
					if (saved) {
						const parsed = JSON.parse(saved);
						if (parsed.version === this.cacheVersion) this.cache = parsed.data;
						else this.cache = {};
					} else this.cache = {};
				} catch (e) { console.error("Failed to load cache", e); this.cache = {}; }
			}

			scheduleSaveCache() {
				if (this.saveTimeout) clearTimeout(this.saveTimeout);
				this.saveTimeout = setTimeout(()=>this.saveCache(), 1000);
			}

			saveCache() {
				try { localStorage.setItem('hijriCalcCache', JSON.stringify({ version: this.cacheVersion, data: this.cache })); }
				catch (e) { console.warn("Failed to save cache", e); }
			}

			savePreferences() {
				(state.lat = parseFloat(elements.latInput.value),
				state.lon = parseFloat(elements.lonInput.value),
				state.lang = elements.language.value,
				state.weekStart = parseInt(elements.weekStart.value),
				state.hijriAdj = parseInt(elements.hijriAdj.value),
				state.primaryCalendar = elements.primaryCalendar.value,
				state.theme = elements.theme.value,
				state.calcMode = elements.calcMode.value,
				localStorage.setItem('hijriCalcState', JSON.stringify({
					lat: state.lat, lon: state.lon, lang: state.lang, weekStart: state.weekStart,
					hijriAdj: state.hijriAdj, primaryCalendar: state.primaryCalendar, theme: state.theme,
					calcMode: state.calcMode
				})),
				this.applyTheme(state.theme),
				this.updateLanguage(state.lang),
				this.render());
			}

			resetPreferences() {
				[state.lat, state.lon, state.lang, state.theme, state.weekStart, state.hijriAdj, state.primaryCalendar, state.calcMode] =
					[6.075, 95.1125, navigator.language?.startsWith('id') ? 'id' : 'en', 'auto', 0, 0, 'gregorian', this.isOffline ? 'heuristic' : 'astronomic'],
				(elements.latInput.value = state.lat,
				elements.lonInput.value = state.lon,
				elements.language.value = state.lang,
				elements.weekStart.value = state.weekStart,
				elements.hijriAdj.value = state.hijriAdj,
				elements.primaryCalendar.value = state.primaryCalendar,
				elements.theme.value = state.theme,
				elements.calcMode.value = state.calcMode,
				this.savePreferences());
			}

			applyTheme(theme) { document.documentElement.className = theme === 'auto' ? '' : theme; elements.theme.value = theme; }
			getTimezoneOffset() { return Math.round(state.lon / 15); }

			setup() {
				(elements.latInput.value = state.lat,
				elements.lonInput.value = state.lon,
				elements.language.value = state.lang,
				elements.weekStart.value = state.weekStart,
				elements.hijriAdj.value = state.hijriAdj,
				elements.primaryCalendar.value = state.primaryCalendar,
				elements.theme.value = state.theme,
				elements.calcMode.value = state.calcMode,
				this.isOffline && (elements.calcMode.value = 'heuristic', elements.calcMode.disabled = true),
				this.setDateToInput(elements.gDateInput, new Date()),
				text.en.months.forEach((month,index)=>{
					const option = document.createElement('option');
					(option.value = index + 1, option.textContent = month, elements.hMonthInput.appendChild(option));
				}),
				(()=>{
					const hijri = this.gregorianToHijri(new Date());
					(elements.hDayInput.value = hijri.day,
					elements.hMonthInput.value = hijri.month,
					elements.hYearInput.value = hijri.year);
				})(),
				this.updateHijriDayLimit(),
				elements.hMonthInput.addEventListener('change',()=>this.updateHijriDayLimit()),
				elements.hYearInput.addEventListener('change',()=>this.updateHijriDayLimit()),
				elements.hYearInput.addEventListener('input',()=>this.updateHijriDayLimit()),
				elements.prefBtn.onclick = ()=>elements.prefDialog.showModal(),
				elements.closePref.onclick = ()=>elements.prefDialog.close(),
				elements.savePrefBtn.onclick = ()=>(this.savePreferences(), elements.prefDialog.close()),
				elements.resetPrefBtn.onclick = ()=>(this.resetPreferences(), elements.prefDialog.close()),
				elements.myLocBtn.onclick = ()=>this.getLocation(),
				elements.todayBtn.onclick = ()=>(
					state.viewDate = new Date(),
					this.setDateToInput(elements.gDateInput, state.viewDate),
					this.updateHijriInputs(state.viewDate),
					this.render()
				),
				elements.prevMonthBtn.onclick = ()=>this.navigateMonth(-1),
				elements.nextMonthBtn.onclick = ()=>this.navigateMonth(1),
				(()=>{
					const handleGo = ()=>{
						const date = this.getDateFromInput(elements.gDateInput);
						date && (state.viewDate = date, this.updateHijriInputs(date), this.render());
					};
					(elements.gDateInput.addEventListener('change', handleGo),
					elements.gDateInput.addEventListener('keydown',e=>e.key === 'Enter' && handleGo()));
				})(),
				(()=>{
					const handleGoH = ()=>{
						const day = parseInt(elements.hDayInput.value), month = parseInt(elements.hMonthInput.value), year = parseInt(elements.hYearInput.value);
						(day && !isNaN(month) && year) && (()=>{
							const gregorian = this.hijriToGregorian(year, month, day);
							(state.viewDate = gregorian, this.render(), this.setDateToInput(elements.gDateInput, gregorian));
						})();
					};
					(elements.goHBtn.onclick = handleGoH,
					[elements.hDayInput, elements.hMonthInput, elements.hYearInput].forEach(el=>el.addEventListener('keydown',e=>e.key === 'Enter' && handleGoH())));
				})(),
				elements.calendar.addEventListener('keydown',e=>{
					const keys = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown', 'Enter', ' '];
					if (!keys.includes(e.key)) return;
					const cell = e.target.closest('.day-cell');
					if (!cell) return;
					if (e.key === 'Enter' || e.key === ' ') return (e.preventDefault(), cell.click());
					if (e.key === 'PageUp' || e.key === 'PageDown') {
						e.preventDefault();
						const currentDateStr = cell.dataset.date;
						if (!currentDateStr) return;
						const delta = (e.key === 'PageDown') ? 1 : -1;
						const targetDate = (()=>{
							if (state.primaryCalendar === 'hijri') {
								const [year, month, day] = currentDateStr.split('-').map(Number);
								const hijri = this.gregorianToHijri(new Date(year, month - 1, day));
								let newMonth = hijri.month + delta, newYear = hijri.year;
								while (newMonth > 11) (newMonth -= 12, newYear++);
								while (newMonth < 0) (newMonth += 12, newYear--);
								return this.hijriToGregorian(newYear, newMonth, hijri.day);
							}
							const [year, month, day] = currentDateStr.split('-').map(Number),
								checkDate = new Date(year, month - 1 + delta, 1),
								daysInMonth = new Date(checkDate.getFullYear(), checkDate.getMonth() + 1, 0).getDate();
							return new Date(checkDate.getFullYear(), checkDate.getMonth(), Math.min(day, daysInMonth));
						})();
						this.navigateMonth(delta);
						const targetIso = `${targetDate.getFullYear()}-${String(targetDate.getMonth()+1).padStart(2,'0')}-${String(targetDate.getDate()).padStart(2,'0')}`,
							targetCell = elements.calendar.querySelector(`.day-cell[data-date="${targetIso}"]`);
						return targetCell ? (cell.tabIndex = -1, targetCell.tabIndex = 0, targetCell.focus()) : (()=>{
							const first = elements.calendar.querySelector('.day-cell');
							first && (cell.tabIndex = -1, first.tabIndex = 0, first.focus());
						})();
					}
					e.preventDefault();
					const cells = Array.from(elements.calendar.querySelectorAll('.day-cell')),
						index = cells.indexOf(cell);
					if (index === -1) return;
					let newIndex = index;
					(e.key === 'ArrowRight' ? newIndex++ : e.key === 'ArrowLeft' ? newIndex-- : e.key === 'ArrowDown' ? newIndex += 7 : e.key === 'ArrowUp' ? newIndex -= 7 : e.key === 'Home' ? newIndex = 0 : e.key === 'End' ? newIndex = cells.length - 1 : 0);
					(newIndex >= 0 && newIndex < cells.length) && (cell.tabIndex = -1, cells[newIndex].tabIndex = 0, cells[newIndex].focus());
				}));
			}

			navigateMonth(delta) {
				state.primaryCalendar === 'hijri' ? (()=>{
					const hijri = this.gregorianToHijri(state.viewDate);
					let newMonth = hijri.month + delta;
					let newYear = hijri.year;
					while (newMonth > 11) { newMonth -= 12; newYear++; }
					while (newMonth < 0) { newMonth += 12; newYear--; }
					const start = this.getAccurateHijriMonthStart(newYear, newMonth);
					state.viewDate = new Date(start.gDate.getTime() + 15 * 86400000);
				})() : state.viewDate.setMonth(state.viewDate.getMonth() + delta),
				this.render();
			}

			updateHijriInputs(date) {
				const hijri = this.gregorianToHijri(date);
				elements.hDayInput.value = hijri.day;
				elements.hMonthInput.value = String(hijri.month);
				elements.hYearInput.value = hijri.year;
				this.updateHijriDayLimit();
			}

			updateHijriDayLimit() {
				const month = parseInt(elements.hMonthInput.value);
				const year = parseInt(elements.hYearInput.value);
				(!isNaN(month) && !isNaN(year)) && (()=>{
					const currentStart = this.getAccurateHijriMonthStart(year, month);
					let nextMonth = month + 1;
					let nextYear = year;
					nextMonth > 11 && (nextMonth = 0, nextYear++);
					const nextStart = this.getAccurateHijriMonthStart(nextYear, nextMonth);
					const daysInMonth = Math.round((nextStart.gDate - currentStart.gDate) / 86400000);
					elements.hDayInput.max = daysInMonth,
					elements.hDayInput.placeholder = `1-${daysInMonth}`,
					parseInt(elements.hDayInput.value) > daysInMonth && (elements.hDayInput.value = daysInMonth);
				})();
			}

			getLocation() {
				const translation = text[state.lang];
				navigator.geolocation ? (()=>{
					const button = elements.myLocBtn;
					(button.disabled = true,
					button.innerHTML = `<span class="spinner"></span> ${translation.locating}`,
					navigator.geolocation.getCurrentPosition(
						p=>(
							elements.latInput.value = p.coords.latitude.toFixed(4),
							elements.lonInput.value = p.coords.longitude.toFixed(4),
							button.disabled = false,
							button.textContent = translation.myLoc
						),
						e=>(
							console.error(e),
							alert(translation.errorLocation + e.message),
							button.disabled = false,
							button.textContent = translation.myLoc
						)
					));
				})() : alert(translation.geoNotSupported);
			}

			formatCoordinates(latitude, longitude) {
				const t = text[state.lang];
				const latDir = latitude >= 0 ? t.dirN : t.dirS;
				const lonDir = longitude >= 0 ? t.dirE : t.dirW;
				return `${Math.abs(latitude)}° ${latDir}, ${Math.abs(longitude)}° ${lonDir}`;
			}

			getDateFromInput(input) {
				if (!input.value) return null;
				const [year, month, day] = input.value.split('-').map(Number);
				return new Date(year, month - 1, day);
			}

			setDateToInput(input, date) {
				const year = date.getFullYear();
				const month = String(date.getMonth() + 1).padStart(2, '0');
				const day = String(date.getDate()).padStart(2, '0');
				input.value = `${year}-${month}-${day}`;
			}

			updateLanguage(language) {
				const translation = text[language],
					weekDays = [translation.weekSun, translation.weekMon, null, null, null, null, translation.weekSat];
				(document.querySelectorAll('[data-i18n]').forEach(el=>{
					const key = el.getAttribute('data-i18n');
					translation[key] && (el.textContent = translation[key]);
				}),
				document.querySelectorAll('[data-i18n-aria]').forEach(el=>{
					const key = el.getAttribute('data-i18n-aria');
					translation[key] && (el.setAttribute('aria-label', translation[key]));
				}),
				document.querySelectorAll('[data-i18n-placeholder]').forEach(el=>{
					const key = el.getAttribute('data-i18n-placeholder');
					translation[key] && (el.placeholder = translation[key]);
				}),
				elements.appSubtitle.textContent = this.formatCoordinates(state.lat, state.lon) + (this.isOffline ? translation.offlineWarning : state.calcMode === 'heuristic' ? translation.heuristicSuffix : ""),
				[...elements.hMonthInput.options].forEach((opt,i)=>opt.textContent = translation.months[i]),
				[...elements.theme.options].forEach(opt=>opt.textContent = translation['theme' + opt.value.charAt(0).toUpperCase() + opt.value.slice(1)]),
				[...elements.primaryCalendar.options].forEach(opt=>opt.textContent = translation['cal' + opt.value.charAt(0).toUpperCase() + opt.value.slice(1)]),
				[...elements.calcMode.options].forEach(opt=>opt.textContent = translation['calcMode' + opt.value.charAt(0).toUpperCase() + opt.value.slice(1)]),
				[...elements.weekStart.options].forEach(opt=>(weekDays[parseInt(opt.value)] && (opt.textContent = weekDays[parseInt(opt.value)]))),
				this.updateFormulaDisplay());
			}

			updateFormulaDisplay() {
				const formula = `JD = 1948440 + floor(29.53057334 * Index + 0.18048400) + Day - 1\nIndex = floor((JD - 1948440 + 0.81951600) / 29.53057334)`;
				elements.formulaDisplay.style.whiteSpace = "pre-line";
				elements.formulaDisplay.textContent = formula;
				elements.formulaNote.innerHTML = `<i>Linear Approximation (1-10000 AH). Index = (Year-1)*12 + Month - 1. Epoch 1 AH = 1948440.</i>`;
			}

			// Core Linear Logic Refactored
			getLinearMonthStartJD(Index) {
				// Intercept at 1 AH (Index 0) is 1948440 + floor(0.18048400) = 1948440.
				// Phase shift 0.18048400 maximizes accuracy (~69.01% for obligatory months 1-10000 AH).
				return 1948440 + Math.floor(29.53057334 * Index + 0.18048400);
			}

			getLinearIndexFromJD(JD) {
				// Derived from 1-10000 AH analysis.
				// Inverse offset = 1.0 - (0.18048400) = 0.81951600.
				return Math.floor((JD - 1948440 + 0.81951600) / 29.53057334);
			}

			jdToGregorianDate(jd) {
				let z = Math.floor(jd + 0.5);
				let f = jd + 0.5 - z;
				let alpha = Math.floor((z - 1867216.25) / 36524.25);
				let a = z + 1 + alpha - Math.floor(alpha / 4);
				let b = a + 1524;
				let c = Math.floor((b - 122.1) / 365.25);
				let d = Math.floor(365.25 * c);
				let e = Math.floor((b - d) / 30.6001);
				let day = b - d - Math.floor(30.6001 * e) + f;
				let month = e - 1;
				if (month > 12) month -= 12;
				let year = c - 4715;
				if (e < 14) month = e - 1; else month = e - 13;
				if (month > 2) year = c - 4716; else year = c - 4715;
				return new Date(year, month - 1, Math.floor(day));
			}

			gregorianDateToJD(date) {
				let day = date.getDate();
				let month = date.getMonth();
				let year = date.getFullYear();
				let m = month + 1;
				let y = year;
				if (m < 3) { y -= 1; m += 12; }
				let a = Math.floor(y / 100);
				let b = 2 - a + Math.floor(a / 4);
				if (y < 1583) b = 0;
				if (y === 1582) {
					if (m > 10) b = -10;
					if (m === 10) { b = 0; if (day > 4) b = -10; }
				}
				return Math.floor(365.25 * (y + 4716)) + Math.floor(30.6001 * (m + 1)) + day + b - 1524;
			}

			hijriToGregorianLinear(hYear, hMonth, hDay) {
				const Index = (hYear - 1) * 12 + hMonth - 1;
				const JD = this.getLinearMonthStartJD(Index) + hDay - 1 + state.hijriAdj;
				return this.jdToGregorianDate(JD);
			}

			hijriToGregorian(hYear, hMonth, hDay) {
				if (this.isOffline || state.calcMode === 'heuristic') return this.hijriToGregorianLinear(hYear, hMonth, hDay);
				const start = this.getAccurateHijriMonthStart(hYear, hMonth);
				const gregorian = new Date(start.gDate);
				gregorian.setDate(gregorian.getDate() + (hDay - 1));
				return gregorian;
			}

			gregorianToHijriLinear(date) {
				let JD = this.gregorianDateToJD(date);
				JD -= state.hijriAdj;
				let Index = this.getLinearIndexFromJD(JD);
				let jdStart = this.getLinearMonthStartJD(Index);
				const hDay = JD - jdStart + 1;
				const hYear = Math.floor(Index / 12) + 1;
				let hMonth = (Index % 12);
				if (hMonth < 0) hMonth += 12;
				return { day: hDay, month: hMonth + 1, year: hYear };
			}

			gregorianToHijri(date) {
				if (this.isOffline || state.calcMode === 'heuristic') return this.gregorianToHijriLinear(date);
				const approx = this.gregorianToHijriLinear(date);
				const startCurrent = this.getAccurateHijriMonthStart(approx.year, approx.month);
				const dateTime = date.getTime();
				const startTime = startCurrent.gDate.getTime();
				if (dateTime < startTime) {
					let prevMonth = approx.month - 1;
					let prevYear = approx.year;
					if (prevMonth < 1) { prevMonth = 12; prevYear--; }
					const startPrev = this.getAccurateHijriMonthStart(prevYear, prevMonth);
					const day = Math.round((dateTime - startPrev.gDate.getTime()) / 86400000) + 1;
					return { day: day, month: prevMonth, year: prevYear };
				}
				let nextMonth = approx.month + 1;
				let nextYear = approx.year;
				if (nextMonth > 12) { nextMonth = 1; nextYear++; }
				const startNext = this.getAccurateHijriMonthStart(nextYear, nextMonth);
				const nextTime = startNext.gDate.getTime();
				if (dateTime >= nextTime) {
					const day = Math.round((dateTime - nextTime) / 86400000) + 1;
					return { day: day, month: nextMonth, year: nextYear };
				}
				const day = Math.round((dateTime - startTime) / 86400000) + 1;
				return { day: day, month: approx.month, year: approx.year };
			}

			checkVisibility(dateObj, knownNewMoonUT) {
				// dateObj is expected to be a Date object centered roughly on the check day (e.g. noon UTC).
				const date = Astronomy.MakeTime(dateObj);
				const observer = new Astronomy.Observer(state.lat, state.lon, 0);

				// Search for sunset on the given date (limit search window to +/- 1 day to be safe, but start at dateObj)
				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
				if (!sunset) return false;
				const sunsetUT = sunset.ut;

				let newMoonUT = knownNewMoonUT;
				if (newMoonUT === undefined || newMoonUT === null) {
					const bestNewMoon = Astronomy.SearchMoonPhase(0, date.ut, -35);
					if (!bestNewMoon) return false;
					newMoonUT = bestNewMoon.ut;
				}

				const age = sunsetUT - newMoonUT;
				if (age < 0) return false;

				const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
				const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, "normal");
				const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
				const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);

				// MABBIMS Criteria: Altitude >= 3 deg, Elongation >= 6.4 deg, Age > 0 (implied)
				return (moonHor.altitude >= 3.0 && elongation >= 6.4);
			}

			getAccurateHijriMonthStart(hYear, hMonth) {
				return (this.isOffline || state.calcMode === 'heuristic') ? { gDate: this.hijriToGregorianLinear(hYear, hMonth, 1) } :
				((!this.cache && this.loadCache()), (()=>{
					const cacheKey = `${hYear}-${hMonth}-${state.lat}-${state.lon}`;
					if (this.cache[cacheKey]) {
						(typeof this.cache[cacheKey].gDate === 'string') && (this.cache[cacheKey].gDate = new Date(this.cache[cacheKey].gDate));
						return this.cache[cacheKey];
					}
					const daysSinceAnchor = ((hYear - 1445) * 354.367) + ((hMonth - 1) * 29.53),
						anchorDate = new Date("2023-07-19T12:00:00Z"),
						approxDate = new Date(anchorDate.getTime() + daysSinceAnchor * 86400000),
						searchStart = new Date(approxDate.getTime() - 5 * 86400000),
						timeStart = Astronomy.MakeTime(searchStart);
					let bestNewMoon = Astronomy.SearchMoonPhase(0, timeStart.ut, 10);
					if (!bestNewMoon || Math.abs(bestNewMoon.date - approxDate) > 4 * 86400000) return { gDate: approxDate };
					const newMoonDate = bestNewMoon.date,
						utcOffset = this.getTimezoneOffset(),
						localNMTime = newMoonDate.getTime() + (utcOffset * 3600000),
						localNMDate = new Date(localNMTime),
						y = localNMDate.getUTCFullYear(),
						m = localNMDate.getUTCMonth(),
						d = localNMDate.getUTCDate(),
						searchCenterUTC = new Date(Date.UTC(y, m, d, 12 - utcOffset, 0, 0)),
						isVisible = this.checkVisibility(searchCenterUTC, bestNewMoon.ut),
						startDay = d + (isVisible ? 1 : 2),
						result = { gDate: new Date(y, m, startDay) };
					return (this.cache[cacheKey] = result, this.scheduleSaveCache(), result);
				})());
			}

			getHijriInfoForCell(date, isGregorianMode, context, hijriStarts) {
				const translation = text[state.lang], dateNoTime = new Date(date).setHours(0, 0, 0, 0);
				let hijriDateDisplay = "", hijriMonthNameDisplay = "";

				isGregorianMode ? (()=>{
					for (let k = 0; k < hijriStarts.length - 1; k++) {
						const s1 = hijriStarts[k], s2 = hijriStarts[k + 1];
						(date >= s1.gDate && date < s2.gDate) && (
							hijriDateDisplay = Math.round((dateNoTime - new Date(s1.gDate).setHours(0, 0, 0, 0)) / 86400000) + 1,
							hijriMonthNameDisplay = translation.months[s1.month - 1],
							k = hijriStarts.length
						);
					}
				})() : (
					(date >= context.startGDate && date < context.endGDate) ? (
						hijriDateDisplay = Math.round((dateNoTime - new Date(context.startGDate).setHours(0, 0, 0, 0)) / 86400000) + 1,
						hijriMonthNameDisplay = translation.months[context.hMonth - 1]
					) : (()=>{
						const start = new Date(context.startGDate).setHours(0, 0, 0, 0),
							diff = Math.round((dateNoTime - start) / 86400000) + 1;
						date < context.startGDate ? (()=>{
							let prevMonth = context.hMonth - 1, prevYear = context.hYear;
							(prevMonth < 1 && (prevMonth += 12, prevYear--));
							const prevStart = this.getAccurateHijriMonthStart(prevYear, prevMonth);
							let prevLength = Math.round((context.startGDate - prevStart.gDate) / 86400000);
							(prevLength < 29 || prevLength > 30) && (prevLength = 30),
							hijriDateDisplay = prevLength + diff,
							hijriMonthNameDisplay = translation.months[prevMonth - 1];
						})() : (()=>{
							let length = Math.round((context.endGDate - context.startGDate) / 86400000);
							(length < 29 || length > 30) && (length = 30);
							let nm = context.hMonth + 1;
							(nm > 12 && (nm = 1)),
							hijriDateDisplay = diff - length,
							hijriMonthNameDisplay = translation.months[nm - 1];
						})();
					})()
				);
				return { day: hijriDateDisplay, monthName: hijriMonthNameDisplay };
			}

			createDayCell(date, hijriInfo, isSelected, isToday, isOtherMonth) {
				const element = document.createElement('div'),
					isGregorianMode = state.primaryCalendar !== 'hijri',
					monthNameShort = date.toLocaleDateString(state.lang === 'id' ? 'id-ID' : 'en-US', { month: 'short' }),
					gregorianText = isGregorianMode ? date.getDate() : `${date.getDate()} ${monthNameShort}`,
					fullDate = date.toLocaleDateString(state.lang === 'id' ? 'id-ID' : 'en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
				return (element.className = 'day-cell',
				element.setAttribute('role', 'gridcell'),
				element.tabIndex = -1,
				isOtherMonth && element.classList.add('other-month'),
				isToday && element.classList.add('today'),
				isSelected && (element.classList.add('selected'), element.setAttribute('aria-selected', 'true')),
				element.onclick = ()=>(
					this.setDateToInput(elements.gDateInput, date),
					this.updateHijriInputs(date),
					this.render(),
					(()=>{
						const selected = elements.calendar.querySelector('.day-cell.selected');
						selected && selected.focus();
					})()
				),
				element.setAttribute('aria-label', `${fullDate}, ${hijriInfo.day} ${hijriInfo.monthName}`),
				element.dataset.date = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`,
				element.innerHTML = `
					<div class="gregorian-date">${gregorianText}</div>
					<div class="hijri-wrapper">
						<div class="hijri-date">${hijriInfo.day}</div>
						<div class="hijri-month-name">${hijriInfo.monthName}</div>
					</div>
				`,
				element);
			}

			render() {
				const grid = elements.calendar, translation = text[state.lang];
				(state.primaryCalendar === 'hijri' ? grid.classList.add('hijri-primary') : grid.classList.remove('hijri-primary'),
				state.primaryCalendar !== 'hijri' ? (()=>{
					const year = state.viewDate.getFullYear(), month = state.viewDate.getMonth(), langCode = state.lang === 'id' ? 'id-ID' : 'en-US';
					elements.monthDisplay.textContent = state.viewDate.toLocaleDateString(langCode, { month: 'long', year: 'numeric' });
					let offset = new Date(year, month, 1).getDay() - state.weekStart;
					(offset < 0 && (offset += 7)),
					this.renderGrid(new Date(year, month, 1 - offset), true, { month, year });
				})() : (()=>{
					const hijri = this.gregorianToHijri(state.viewDate), currentStart = this.getAccurateHijriMonthStart(hijri.year, hijri.month);
					let nextMonth = hijri.month + 1, nextYear = hijri.year;
					(nextMonth > 12 && (nextMonth = 1, nextYear++));
					const nextStart = this.getAccurateHijriMonthStart(nextYear, nextMonth);
					elements.monthDisplay.textContent = `${translation.months[hijri.month - 1]} ${hijri.year}`;
					let offset = currentStart.gDate.getDay() - state.weekStart;
					(offset < 0 && (offset += 7));
					const gridStartDate = new Date(currentStart.gDate);
					(gridStartDate.setDate(gridStartDate.getDate() - offset),
					this.renderGrid(gridStartDate, false, { hMonth: hijri.month, hYear: hijri.year, startGDate: currentStart.gDate, endGDate: nextStart.gDate }));
				})());
			}

			renderGrid(gridStartDate, isGregorianMode, context) {
				const grid = elements.calendar, translation = text[state.lang], fragment = document.createDocumentFragment();
				(grid.setAttribute('role', 'grid'), grid.innerHTML = '');

				for (let index = 0; index < 7; index++) {
					const dayIndex = (state.weekStart + index) % 7, element = document.createElement('div');
					(element.className = 'day-header', element.textContent = translation.days[dayIndex], element.setAttribute('role', 'columnheader'), fragment.appendChild(element));
				}

				let hijriStarts = [];
				isGregorianMode && (()=>{
					const startHijri = this.gregorianToHijri(gridStartDate);
					let hMonthIndex = startHijri.month, hYear = startHijri.year;
					for (let index = -1; index <= 3; index++) {
						let month = hMonthIndex + index, year = hYear;
						while (month > 12) (month -= 12, year++);
						while (month < 1) (month += 12, year--);
						const start = this.getAccurateHijriMonthStart(year, month);
						hijriStarts.push({ year, month, gDate: start.gDate });
					}
					hijriStarts.sort((a,b)=>a.gDate - b.gDate);
				})();

				const today = new Date().setHours(0, 0, 0, 0), selectedDate = this.getDateFromInput(elements.gDateInput), selectedTime = selectedDate ? selectedDate.getTime() : -1;

				for (let index = 0; index < 42; index++) {
					const date = new Date(gridStartDate);
					date.setDate(gridStartDate.getDate() + index);
					const hijriInfo = this.getHijriInfoForCell(date, isGregorianMode, context, hijriStarts),
						isOtherMonth = isGregorianMode ? (date.getMonth() !== context.month) : (date < context.startGDate || date >= context.endGDate),
						dateTime = date.getTime(),
						isToday = (dateTime === today),
						isSelected = (dateTime === selectedTime),
						element = this.createDayCell(date, hijriInfo, isSelected, isToday, isOtherMonth);
					fragment.appendChild(element);
				}
				(grid.appendChild(fragment), (()=>{
					const cells = grid.querySelectorAll('.day-cell');
					let focusCandidate = grid.querySelector('.day-cell.selected') || grid.querySelector('.day-cell.today') || (cells.length > 0 ? cells[0] : null);
					focusCandidate && (focusCandidate.tabIndex = 0);
				})());
			}
		}
		new HijriCalc();
	</script>
</body>
</html>
